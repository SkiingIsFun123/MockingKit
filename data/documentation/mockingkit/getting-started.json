{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Installation","level":2,"type":"heading","text":"Installation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"MockingKit can be installed with the Swift Package Manager:"}]},{"type":"codeListing","syntax":null,"code":["https:\/\/github.com\/danielsaidi\/MockingKit.git"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"or with CocoaPods:"}]},{"type":"codeListing","syntax":null,"code":["pod MockingKit"]},{"anchor":"Terminology","level":2,"type":"heading","text":"Terminology"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Before we continue, let’s clarify what this means in detail."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Invokation"},{"type":"text","text":" is to call a function. In a mock, this records the call and saves information about how many times a function has been called, with which arguments, the returned result etc."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Inspection"},{"type":"text","text":" is to look at recorded invokation and use it e.g. in a unit test. For instance, we can verify that a function has been triggered only once, with certain arguments etc."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Registration"},{"type":"text","text":" is to pre-register a dynamic return value for a function, based on the arguments with which the function is called."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s have a look at how this works in MockingKit."}]},{"anchor":"Creating-a-mock","level":2,"type":"heading","text":"Creating a mock"},{"type":"paragraph","inlineContent":[{"type":"text","text":"MockingKit can be used to mock any protocol or class, for instance when unit testing or mocking not yet implemented functionality."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For instance, say that you have a "},{"type":"codeVoice","code":"MyProtocol"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["protocol MyProtocol {","","    func doStuff(int: Int, string: String) -> String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can then create a mock implementation of the protocol by creating a mock class that inherits the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mock"},{"type":"text","text":" base class and implements "},{"type":"codeVoice","code":"MyProtocol"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["class MyMock: Mock, MyProtocol {","","    \/\/ You have to define a lazy reference for each function ","    lazy var doStuffRef = MockReference(doStuff)","","    \/\/ Functions must then call the reference to be recorded","    func doStuff(int: Int, string: String) -> String {","        call(doStuffRef, args: (int, string))","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your mock can’t inherit "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mock"},{"type":"text","text":", e.g. when mocking structs or inheriting another base class, you can implement the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mockable"},{"type":"text","text":" protocol instead, by just providing a custom "},{"type":"codeVoice","code":"mock"},{"type":"text","text":" instance:"}]},{"type":"codeListing","syntax":"swift","code":["class MyMock: MyBaseClass, Mockable, MyProtocol {","","    let mock = Mock()","    ","    \/\/ ... the rest is the same. `Mock` just saves you one line of code :)","}"]},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mock"},{"type":"text","text":" is basically just a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mockable"},{"type":"text","text":" that returns itself as "},{"type":"reference","isActive":true,"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mockable\/mock"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"With the mock in place, you can use it to mock functionality in your unit tests or app."}]},{"anchor":"Using-the-mock","level":2,"type":"heading","text":"Using the mock"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can now use the mock to register function results, call functions and inspect calls:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Create a mock","let mock = MyMock()","","\/\/ Register a result for when calling doStuff","mock.registerResult(for: mock.doStuffRef) { args in String(args.1.reversed()) }","","\/\/ Calling doStuff will now return the pre-registered result","let result = mock.doStuff(int: 42, string: \"string\")    \/\/ => \"gnirts\"","","\/\/ You can also inspect all calls that made to doStuff","let calls = mock.calls(to: mock.doStuffRef)             \/\/ => 1 item","calls[0].arguments.0                                    \/\/ => 42","calls[0].arguments.1                                    \/\/ => \"string\"","calls[0].result                                         \/\/ => \"gnirts\"","mock.hasCalled(mock.doStuffRef)                         \/\/ => true","mock.hasCalled(mock.doStuffRef, numberOfTimes: 1)       \/\/ => true","mock.hasCalled(mock.doStuffRef, numberOfTimes: 2)       \/\/ => false"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a return value is optional, it’s also optional to register a return value before invoking the function. Calling "},{"type":"codeVoice","code":"invoke"},{"type":"text","text":" before registering a return value will return "},{"type":"codeVoice","code":"nil"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the return value is non-optional, you must register a return value before invoking the function. Calling "},{"type":"codeVoice","code":"invoke"},{"type":"text","text":" before registering a return value will cause a crash."}]},{"anchor":"Multiple-function-arguments","level":2,"type":"heading","text":"Multiple function arguments"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a mocked function has multiple arguments, inspection behaves a little different, since arguments are handled as tuples."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Say that we have a protocol that looks like this:"}]},{"type":"codeListing","syntax":"swift","code":["protocol MyProtocol {","","    func doStuff(int: Int, string: String) -> String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A MockingKit mock would look like this:"}]},{"type":"codeListing","syntax":"swift","code":["class MyMock: Mock, MyProtocol {","","    lazy var doStuffRef = MockReference(doStuff)","","    func doStuff(int: Int, string: String) -> String {","        invoke(doStuffRef, args: (int, string))","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since function arguments are handled as tuples, you now use tuple positions to inspect arguments:"}]},{"type":"codeListing","syntax":"swift","code":["let mock = MyMock()","mock.registerResult(for: mock.doStuffRef) { args in String(args.1.reversed()) }","let result = mock.doStuff(int: 42, string: \"string\")    \/\/ => \"gnirts\"","let inv = mock.invokations(of: mock.doStuffRef)         \/\/ => 1 item","inv[0].arguments.0                                      \/\/ => 42","inv[0].arguments.1                                      \/\/ => \"message\"","inv[0].result                                           \/\/ => \"gnirts\"","mock.hasInvoked(mock.doStuffRef)                        \/\/ => true","mock.hasInvoked(mock.doStuffRef, numberOfTimes: 1)      \/\/ => true","mock.hasInvoked(mock.doStuffRef, numberOfTimes: 2)      \/\/ => false"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is no upper-limit to the number of function arguments you can use in a mocked function."}]},{"anchor":"Multiple-functions-with-the-same-name","level":2,"type":"heading","text":"Multiple functions with the same name"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your mock has multiple methods with the same name:"}]},{"type":"codeListing","syntax":"swift","code":["protocol MyProtocol {","","    func doStuff(with int: Int) -> Bool","    func doStuff(with int: Int, string: String) -> String","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"your must explicitly specify the function signature when creating references:"}]},{"type":"codeListing","syntax":"swift","code":["class MyMock: Mock, MyProtocol {","","    lazy var doStuffWithIntRef = MockReference(doStuff as (Int) -> Bool)","    lazy var doStuffWithIntAndStringRef = MockReference(doStuff as (Int, String) -> String)","","    func doStuff(with int: Int) -> Bool {","        invoke(doStuffWithInt, args: (int))","    }","","    func doStuff(with int: Int, string: String) -> String {","        invoke(doStuffWithIntAndStringRef, args: (int, string))","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is actually nice, since it gives you a unique references for each function. It also makes the unit test code easier to write."}]},{"anchor":"Properties","level":2,"type":"heading","text":"Properties"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In MockingKit, properties can’t be mocked with function references, since the function reference model requires a function. To fake the value of a mock property, just set the properties of the mock right away."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you however for some reason want to inspect how a property is called, modified etc., you can invoke custom references to private functions in the getter and\/or setter."}]},{"anchor":"Async-functions","level":2,"type":"heading","text":"Async functions"},{"type":"paragraph","inlineContent":[{"type":"text","text":"MockingKit supports Swift concurrency and lets you mock any "},{"type":"codeVoice","code":"async"},{"type":"text","text":" function."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Mocking "},{"type":"codeVoice","code":"async"},{"type":"text","text":" functions works exactly like mocking non-async functions. No additional code is required."}]},{"anchor":"Completion-blocks","level":2,"type":"heading","text":"Completion blocks"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Functions with completion blocks are just "},{"type":"codeVoice","code":"Void"},{"type":"text","text":" return functions where the completion block is just arguments like any others."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Mocking these kind of functions works exactly like mocking any other functions. No additional code is required."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You must however manually call the completions from within your mocks if you want them to trigger."}]},{"anchor":"Conclusion","level":2,"type":"heading","text":"Conclusion"},{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s about it. Enjoy using this library to mock functionality in SwiftUI!"}]}]}],"schemaVersion":{"major":0,"minor":2,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/mockingkit\/getting-started"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/MockingKit\/documentation\/MockingKit\/Getting-Started","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"This article describes how you get started with MockingKit."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Getting started","role":"article","modules":[{"name":"MockingKit"}]},"hierarchy":{"paths":[["doc:\/\/MockingKit\/documentation\/MockingKit"]]},"references":{"doc://MockingKit/documentation/MockingKit/Mockable":{"role":"symbol","title":"Mockable","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"Mockable"}],"abstract":[{"type":"text","text":"This protocol can be implemented by any type that should be"},{"type":"text","text":" "},{"type":"text","text":"used as a mock, e.g. when unit testing."}],"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mockable","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Mockable"}],"url":"\/documentation\/mockingkit\/mockable"},"doc://MockingKit/documentation/MockingKit":{"role":"collection","title":"MockingKit","abstract":[{"type":"text","text":"MockingKit is a Swift-based mocking library that makes it easy to mock protocols and classes, for instance when unit testing or mocking not yet implemented functionality."}],"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit","kind":"symbol","type":"topic","url":"\/documentation\/mockingkit"},"doc://MockingKit/documentation/MockingKit/Mockable/mock":{"role":"symbol","title":"mock","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"mock"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Mock","preciseIdentifier":"s:10MockingKit4MockC"}],"abstract":[],"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mockable\/mock","kind":"symbol","required":true,"type":"topic","url":"\/documentation\/mockingkit\/mockable\/mock"},"doc://MockingKit/documentation/MockingKit/Mock":{"role":"symbol","title":"Mock","fragments":[{"kind":"keyword","text":"class"},{"kind":"text","text":" "},{"kind":"identifier","text":"Mock"}],"abstract":[{"type":"text","text":"This class can be inherited any classes that should be used"},{"type":"text","text":" "},{"type":"text","text":"as mock implementation, e.g. when unit testing."}],"identifier":"doc:\/\/MockingKit\/documentation\/MockingKit\/Mock","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Mock"}],"url":"\/documentation\/mockingkit\/mock"}}}